{% extends 'base.html' %}

{% block title %}
    Paging - Wiki
{% endblock %}

{% block body %}
    <div class="main-container">
        <div class="card-container">
            <h1 class="page-heading">Paging</h1>
        </div>
    </div>
    <div class="text">
        <p>To reduce fragmentation, all data is split into small fix-sized blocks called pages and are then stored. 
            The main memory is also divided into fix-sized blocks called frames. The frame size is generally kept 
            the same as the size of a page for optimal performance.</p>
        <p>
            This process allows the OS to load pages onto the frames in main memory rather that loading data 
            byte wise or in terms of segments having random sizes. It is non contiguous as all the pages need not 
            be loaded onto continuous pages
        </p>
        <img src = "/static/pic/page_replacement/p1.png">
        <p> 
            Main components in paging are: 
        <li> Logical Address or Virtual Address (represented in bits): An address generated by the 
            CPU</li>
        <li>Logical Address Space or Virtual Address Space (represented in words or bytes): The 
            set of all logical addresses generated by a program </li>
        <li>Physical Address (represented in bits): An address actually available on memory unit</li>
        <li>Physical Address Space (represented in words or bytes): The set of all physical 
            addresses corresponding to the logical addresses</li>
        
        <p>
            The mapping from virtual to physical address is done by the memory management unit (MMU) 
            which is a hardware device and this mapping is known as paging technique.
            Address generated by CPU is divided into:
            <li>Page number(p): Number of bits required to represent the pages in Logical Address 
                Space or Page number</li>
            <li>Page offset(d): Number of bits required to represent particular word in a page or page 
                size of Logical Address Space or word number of a page or page offset.</li>
            <br>
            Physical Address is divided into:
            <li>Frame number(f): Number of bits required to represent the frame of Physical Address 
                Space or Frame number.
                </li>
            <li>Frame offset(d): Number of bits required to represent particular word in a frame or 
                frame size of Physical Address Space or word number of a frame or frame offset.
                </li> 
                <br>
                The mapping from Page number to Frame number is stored in a structure called Page Table.
        </p>
        <p>
            <img src = "/static/pic/page_replacement/p2.png">
            <img src = "/static/pic/page_replacement/p3.png">
        </p>
        <p>
            Here, are advantages of using Paging method:
            <li>Easy to use memory management algorithm </li>
            <li>No external Fragmentation </li> 
            <li>Swapping is easy between equal-sized pages and page frames </li>
        <br><br>
            Here, are the drawback/cons of using Paging:
            <li>May cause Internal fragmentation </li>
            <li>Page tables consume additional memory</li> 
            <li>Multi-level paging may lead to memory reference overhead.</li>
        </p>
        <p>
            Page Replacement Algorithms:<br>
            In an operating system that uses paging for memory management, a page replacement algorithm 
            is needed to decide which page needs to be replaced when a new page comes in.<br>
            A <strong>page fault</strong> happens when a running program accesses a memory page that is 
            mapped into the virtual address space but not loaded in physical memory.<br>
            Since actual physical memory is much smaller than virtual memory, page faults happen. In case of 
            a page fault, Operating System might have to replace one of the existing pages with the newly 
            needed page. Different page replacement algorithms suggest different ways to decide which page 
            to replace. The target for all algorithms is to reduce the number of page faults.<br>
           <ol>
               <li>First In First Out (FIFO):
                This is the simplest page replacement algorithm. In this algorithm, the operating system keeps 
                track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a 
                page needs to be replaced page in the front of the queue is selected for removal</li>
                <li>Optimal Page replacement:
                    In this algorithm, pages are replaced which would not be used for the longest duration of time in 
                    the future.
                    </li>
                <li>Least Recently Used:
                    In this algorithm, least recently used page will be replaced.</li>
           </ol>
        Belady’s anomaly : Belady’s anomaly proves that it is possible to have more page faults when 
        increasing the number of page frames. It is observed in FIFO but not in OPT and LRU. (This is 
        because LRU and OPT are stack algorithms while FIFO is not)
        </p>
        <img src = "/static/pic/page_replacement/p4.png">
    </div>
{% endblock %}